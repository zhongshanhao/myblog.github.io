<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python机器学习--感知机</title>
      <link href="/2019/10/03/ganzhiji/"/>
      <url>/2019/10/03/ganzhiji/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapclass Perceptron(object):    def __init__(self, eta=0.01, n_iter=50, random_state=1):                self.eta = eta                self.n_iter = n_iter                self.random_state = random_state    def fit(self, X, y):        rgen = np.random.RandomState(self.random_state)                self.w_ = rgen.normal(loc=0.0, scale=0.01,size=1 + X.shape[1])                self.errors_ = []        for _ in range(self.n_iter):                        errors = 0                        for xi, target in zip(X, y):                                update = self.eta * (target - self.predict(xi))                                self.w_[1:] += update * xi                                self.w_[0] += update                                errors += int(update != 0.0)                        self.errors_.append(errors)                return self    def net_input(self, X):                &quot;&quot;&quot;Calculate net input&quot;&quot;&quot;                return np.dot(X, self.w_[1:]) + self.w_[0]    def predict(self, X):                &quot;&quot;&quot;Return class label after unit step&quot;&quot;&quot;                return np.where(self.net_input(X) &gt;= 0.0, 1, -1)</code></pre><pre><code class="python">df = pd.read_csv(&#39;https://archive.ics.uci.edu/ml/&#39; ...              &#39;machine-learning-databases/iris/iris.data&#39;, ...               header=None) df.tail()</code></pre><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th {    vertical-align: middle;}.dataframe thead th {    text-align: right;}</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>0</th>      <th>1</th>      <th>2</th>      <th>3</th>      <th>4</th>    </tr>  </thead>  <tbody>    <tr>      <th>145</th>      <td>6.7</td>      <td>3.0</td>      <td>5.2</td>      <td>2.3</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>146</th>      <td>6.3</td>      <td>2.5</td>      <td>5.0</td>      <td>1.9</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>147</th>      <td>6.5</td>      <td>3.0</td>      <td>5.2</td>      <td>2.0</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>148</th>      <td>6.2</td>      <td>3.4</td>      <td>5.4</td>      <td>2.3</td>      <td>Iris-virginica</td>    </tr>    <tr>      <th>149</th>      <td>5.9</td>      <td>3.0</td>      <td>5.1</td>      <td>1.8</td>      <td>Iris-virginica</td>    </tr>  </tbody></table></div><pre><code class="python">import matplotlib.pyplot as plt# select setosa and versicolor y = df.iloc[0:100, 4].values y = np.where(y == &#39;Iris-setosa&#39;, -1, 1)# extract sepal length and petal length X = df.iloc[0:100, [0, 2]].values# plot data plt.scatter(X[:50, 0], X[:50, 1], label=&#39;setosa&#39;) plt.scatter(X[50:100, 0], X[50:100, 1],marker=&#39;x&#39;,label=&#39;versicolor&#39;)  plt.xlabel(&#39;sepal length [cm]&#39;) plt.ylabel(&#39;petal length [cm]&#39;)plt.legend(loc=&#39;upper left&#39;) plt.show() </code></pre><p><img src="http://i2.tiimg.com/700703/d147555495de8c6b.png" alt="Markdown"></p><pre><code class="python">ppn = Perceptron(eta=0.1,n_iter=10)ppn.fit(X, y)plt.plot(range(1, len(ppn.errors_) + 1), ppn.errors_, marker=&#39;o&#39;) plt.xlabel(&#39;Epochs&#39;)plt.ylabel(&#39;Number of updates&#39;)plt.show()</code></pre><p><img src="http://i2.tiimg.com/700703/0f0a93745808decc.png" alt="Markdown"></p><pre><code class="python">def plot_decision_regions(X, y, classifier, resolution=0.02):    # setup marker generator and color map        markers = (&#39;s&#39;, &#39;x&#39;, &#39;o&#39;, &#39;^&#39;, &#39;v&#39;)        colors = (&#39;red&#39;, &#39;blue&#39;, &#39;lightgreen&#39;, &#39;gray&#39;, &#39;cyan&#39;)        cmap = ListedColormap(colors[:len(np.unique(y))])    # plot the decision surface        x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1        x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1        xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),                                                      np.arange(x2_min, x2_max, resolution))        Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T)        Z = Z.reshape(xx1.shape)        plt.contourf(xx1, xx2, Z, alpha=0.3, cmap=cmap)        plt.xlim(xx1.min(), xx1.max())        plt.ylim(xx2.min(), xx2.max())    # plot class samples        for idx, cl in enumerate(np.unique(y)):                plt.scatter(x=X[y == cl, 0],                                        y=X[y == cl, 1],                                        alpha=0.8,                                        c=colors[idx],                                        marker=markers[idx],                                        label=cl,                                        edgecolor=&#39;black&#39;)plot_decision_regions(X, y, classifier=ppn)plt.xlabel(&#39;sepal length [cm]&#39;)plt.ylabel(&#39;petal length [cm]&#39;)plt.legend(loc=&#39;upper left&#39;)plt.show()</code></pre><p><img src="http://i2.tiimg.com/700703/15a977e327e47b82.png" alt="Markdown"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy_矩阵切片</title>
      <link href="/2019/10/03/numpy-array/"/>
      <url>/2019/10/03/numpy-array/</url>
      
        <content type="html"><![CDATA[<p>和python列表一样，numpy库中array也有着可切片的特性，这大大方便了我们对矩阵的可操作性。</p><pre><code class="python">import numpy as npa = np.arange(12)a.shape = (3,4)   #同写法a = a.reshape(3,4)print(a)</code></pre><p>首先我们现创建一个3*4的矩阵，如下：</p><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]</code></pre><p>可通过a[x,y]选择第x+1行第y+1列的元素</p><pre><code class="python">print(a[2,3]) #选择矩阵第3行第4列</code></pre><pre><code>11</code></pre><p>通过以下方法可对矩阵进行切割。</p><p>a[:,y]中“：”表示选择所有行，y表示选择第y+1列，a[:,1]表示选择矩阵a第2列的所有行，也就是[1 5 9]；</p><p>a[1,:]表示选择矩阵a第2行的所有列，也就是[4 5 6 7]。</p><p>a[:,:2]表示选择矩阵a第1和第2列的所有行。</p><pre><code class="python">print(a[:,1])  #选择矩阵第二列 print(a[1,:])  #选择矩阵第二行  print(a[:,:2]) #选择矩阵第一和第二列</code></pre><pre><code>[1 5 9][4 5 6 7][[0 1] [4 5] [8 9]]</code></pre><p>选择矩阵第2，3行和第2，3列</p><pre><code>print(a[1:,1:3]) </code></pre><pre><code>[[ 5  6] [ 9 10]]</code></pre><p>用ravel()方法可将矩阵按行展开</p><pre><code class="python">print(a.ravel())#将矩阵转换成列表</code></pre><pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11]</code></pre><p>方法np.where(condition,x1,x2)，矩阵元素满足condition则选择用x1替换，否则用x2替换</p><pre><code class="python">y = np.array([&#39;one&#39;,&#39;zreo&#39;,&#39;one&#39;])y = np.where(y == &#39;one&#39;,1,0) #满足条件选1，不满足选0print(y)</code></pre><pre><code>[1 0 1]</code></pre>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在博客之前</title>
      <link href="/2019/10/02/whyblog/"/>
      <url>/2019/10/02/whyblog/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-Blog？"><a href="#Why-Blog？" class="headerlink" title="Why Blog？"></a>Why Blog？</h2><blockquote><p>记录日常学习笔记。</p><p>方便快速复习已经学过的知识。</p><p>增加写文能力。</p><p>希望能帮助到其他人。</p></blockquote><h2 id="工匠精神"><a href="#工匠精神" class="headerlink" title="工匠精神"></a>工匠精神</h2><p>当今社会，经济和技术高速发展，身处于这样一个时代的我们难免有些浮躁。我所推崇的”工匠精神“，是一种刻骨钻研、追求创新的精神。我所希望的是，任何一种职业，不管在学习还是工作中，都应该像一名工匠一样，尽自己所能把事情做好，做精。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
